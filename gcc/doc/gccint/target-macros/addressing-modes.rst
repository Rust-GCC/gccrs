..
  Copyright 1988-2022 Free Software Foundation, Inc.
  This is part of the GCC manual.
  For copying conditions, see the copyright.rst file.

.. index:: addressing modes

.. _addressing-modes:

Addressing Modes
****************

.. prevent bad page break with this line

This is about addressing modes.

.. c:macro:: HAVE_PRE_INCREMENT
             HAVE_PRE_DECREMENT
             HAVE_POST_INCREMENT
             HAVE_POST_DECREMENT

  A C expression that is nonzero if the machine supports pre-increment,
  pre-decrement, post-increment, or post-decrement addressing respectively.

.. c:macro:: HAVE_PRE_MODIFY_DISP
             HAVE_POST_MODIFY_DISP

  A C expression that is nonzero if the machine supports pre- or
  post-address side-effect generation involving constants other than
  the size of the memory operand.

.. c:macro:: HAVE_PRE_MODIFY_REG
             HAVE_POST_MODIFY_REG

  A C expression that is nonzero if the machine supports pre- or
  post-address side-effect generation involving a register displacement.

.. c:macro:: CONSTANT_ADDRESS_P (x)

  A C expression that is 1 if the RTX :samp:`{x}` is a constant which
  is a valid address.  On most machines the default definition of
  ``(CONSTANT_P (x) && GET_CODE (x) != CONST_DOUBLE)``
  is acceptable, but a few machines are more restrictive as to which
  constant addresses are supported.

.. c:macro:: CONSTANT_P (x)

  ``CONSTANT_P``, which is defined by target-independent code,
  accepts integer-values expressions whose values are not explicitly
  known, such as ``symbol_ref``, ``label_ref``, and ``high``
  expressions and ``const`` arithmetic expressions, in addition to
  ``const_int`` and ``const_double`` expressions.

.. c:macro:: MAX_REGS_PER_ADDRESS

  A number, the maximum number of registers that can appear in a valid
  memory address.  Note that it is up to you to specify a value equal to
  the maximum number that ``TARGET_LEGITIMATE_ADDRESS_P`` would ever
  accept.

.. include:: tm.rst.in
  :start-after: [TARGET_LEGITIMATE_ADDRESS_P]
  :end-before: [TARGET_LEGITIMATE_ADDRESS_P]


.. c:macro:: TARGET_MEM_CONSTRAINT

  A single character to be used instead of the default ``'m'``
  character for general memory addresses.  This defines the constraint
  letter which matches the memory addresses accepted by
  ``TARGET_LEGITIMATE_ADDRESS_P``.  Define this macro if you want to
  support new address formats in your back end without changing the
  semantics of the ``'m'`` constraint.  This is necessary in order to
  preserve functionality of inline assembly constructs using the
  ``'m'`` constraint.

.. c:macro:: FIND_BASE_TERM (x)

  A C expression to determine the base term of address :samp:`{x}`,
  or to provide a simplified version of :samp:`{x}` from which :samp:`alias.cc`
  can easily find the base term.  This macro is used in only two places:
  ``find_base_value`` and ``find_base_term`` in :samp:`alias.cc`.

  It is always safe for this macro to not be defined.  It exists so
  that alias analysis can understand machine-dependent addresses.

  The typical use of this macro is to handle addresses containing
  a label_ref or symbol_ref within an UNSPEC.

.. include:: tm.rst.in
  :start-after: [TARGET_LEGITIMIZE_ADDRESS]
  :end-before: [TARGET_LEGITIMIZE_ADDRESS]


.. c:macro:: LEGITIMIZE_RELOAD_ADDRESS (x, mode, opnum, type, ind_levels, win)

  A C compound statement that attempts to replace :samp:`{x}`, which is an address
  that needs reloading, with a valid memory address for an operand of mode
  :samp:`{mode}`.  :samp:`{win}` will be a C statement label elsewhere in the code.
  It is not necessary to define this macro, but it might be useful for
  performance reasons.

  For example, on the i386, it is sometimes possible to use a single
  reload register instead of two by reloading a sum of two pseudo
  registers into a register.  On the other hand, for number of RISC
  processors offsets are limited so that often an intermediate address
  needs to be generated in order to address a stack slot.  By defining
  ``LEGITIMIZE_RELOAD_ADDRESS`` appropriately, the intermediate addresses
  generated for adjacent some stack slots can be made identical, and thus
  be shared.

  .. note::

    This macro should be used with caution.  It is necessary
    to know something of how reload works in order to effectively use this,
    and it is quite easy to produce macros that build in too much knowledge
    of reload internals.

  .. note::

    This macro must be able to reload an address created by a
    previous invocation of this macro.  If it fails to handle such addresses
    then the compiler may generate incorrect code or abort.

  .. index:: push_reload

  The macro definition should use ``push_reload`` to indicate parts that
  need reloading; :samp:`{opnum}`, :samp:`{type}` and :samp:`{ind_levels}` are usually
  suitable to be passed unaltered to ``push_reload``.

  The code generated by this macro must not alter the substructure of
  :samp:`{x}`.  If it transforms :samp:`{x}` into a more legitimate form, it
  should assign :samp:`{x}` (which will always be a C variable) a new value.
  This also applies to parts that you change indirectly by calling
  ``push_reload``.

  .. index:: strict_memory_address_p

  The macro definition may use ``strict_memory_address_p`` to test if
  the address has become legitimate.

  .. index:: copy_rtx

  If you want to change only a part of :samp:`{x}`, one standard way of doing
  this is to use ``copy_rtx``.  Note, however, that it unshares only a
  single level of rtl.  Thus, if the part to be changed is not at the
  top level, you'll need to replace first the top level.
  It is not necessary for this macro to come up with a legitimate
  address;  but often a machine-dependent strategy can generate better code.

.. include:: tm.rst.in
  :start-after: [TARGET_MODE_DEPENDENT_ADDRESS_P]
  :end-before: [TARGET_MODE_DEPENDENT_ADDRESS_P]


.. include:: tm.rst.in
  :start-after: [TARGET_LEGITIMATE_CONSTANT_P]
  :end-before: [TARGET_LEGITIMATE_CONSTANT_P]


.. include:: tm.rst.in
  :start-after: [TARGET_PRECOMPUTE_TLS_P]
  :end-before: [TARGET_PRECOMPUTE_TLS_P]


.. include:: tm.rst.in
  :start-after: [TARGET_DELEGITIMIZE_ADDRESS]
  :end-before: [TARGET_DELEGITIMIZE_ADDRESS]


.. include:: tm.rst.in
  :start-after: [TARGET_CONST_NOT_OK_FOR_DEBUG_P]
  :end-before: [TARGET_CONST_NOT_OK_FOR_DEBUG_P]


.. include:: tm.rst.in
  :start-after: [TARGET_CANNOT_FORCE_CONST_MEM]
  :end-before: [TARGET_CANNOT_FORCE_CONST_MEM]


.. include:: tm.rst.in
  :start-after: [TARGET_USE_BLOCKS_FOR_CONSTANT_P]
  :end-before: [TARGET_USE_BLOCKS_FOR_CONSTANT_P]


.. include:: tm.rst.in
  :start-after: [TARGET_USE_BLOCKS_FOR_DECL_P]
  :end-before: [TARGET_USE_BLOCKS_FOR_DECL_P]


.. include:: tm.rst.in
  :start-after: [TARGET_BUILTIN_RECIPROCAL]
  :end-before: [TARGET_BUILTIN_RECIPROCAL]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD]
  :end-before: [TARGET_VECTORIZE_BUILTIN_MASK_FOR_LOAD]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST]
  :end-before: [TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT]
  :end-before: [TARGET_VECTORIZE_PREFERRED_VECTOR_ALIGNMENT]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE]
  :end-before: [TARGET_VECTORIZE_VECTOR_ALIGNMENT_REACHABLE]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_VEC_PERM_CONST]
  :end-before: [TARGET_VECTORIZE_VEC_PERM_CONST]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION]
  :end-before: [TARGET_VECTORIZE_BUILTIN_VECTORIZED_FUNCTION]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION]
  :end-before: [TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT]
  :end-before: [TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_PREFERRED_SIMD_MODE]
  :end-before: [TARGET_VECTORIZE_PREFERRED_SIMD_MODE]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_SPLIT_REDUCTION]
  :end-before: [TARGET_VECTORIZE_SPLIT_REDUCTION]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES]
  :end-before: [TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_MODES]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_RELATED_MODE]
  :end-before: [TARGET_VECTORIZE_RELATED_MODE]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_GET_MASK_MODE]
  :end-before: [TARGET_VECTORIZE_GET_MASK_MODE]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE]
  :end-before: [TARGET_VECTORIZE_EMPTY_MASK_IS_EXPENSIVE]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_CREATE_COSTS]
  :end-before: [TARGET_VECTORIZE_CREATE_COSTS]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_BUILTIN_GATHER]
  :end-before: [TARGET_VECTORIZE_BUILTIN_GATHER]


.. include:: tm.rst.in
  :start-after: [TARGET_VECTORIZE_BUILTIN_SCATTER]
  :end-before: [TARGET_VECTORIZE_BUILTIN_SCATTER]


.. include:: tm.rst.in
  :start-after: [TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN]
  :end-before: [TARGET_SIMD_CLONE_COMPUTE_VECSIZE_AND_SIMDLEN]


.. include:: tm.rst.in
  :start-after: [TARGET_SIMD_CLONE_ADJUST]
  :end-before: [TARGET_SIMD_CLONE_ADJUST]


.. include:: tm.rst.in
  :start-after: [TARGET_SIMD_CLONE_USABLE]
  :end-before: [TARGET_SIMD_CLONE_USABLE]


.. include:: tm.rst.in
  :start-after: [TARGET_SIMT_VF]
  :end-before: [TARGET_SIMT_VF]


.. include:: tm.rst.in
  :start-after: [TARGET_OMP_DEVICE_KIND_ARCH_ISA]
  :end-before: [TARGET_OMP_DEVICE_KIND_ARCH_ISA]


.. include:: tm.rst.in
  :start-after: [TARGET_GOACC_VALIDATE_DIMS]
  :end-before: [TARGET_GOACC_VALIDATE_DIMS]


.. include:: tm.rst.in
  :start-after: [TARGET_GOACC_DIM_LIMIT]
  :end-before: [TARGET_GOACC_DIM_LIMIT]


.. include:: tm.rst.in
  :start-after: [TARGET_GOACC_FORK_JOIN]
  :end-before: [TARGET_GOACC_FORK_JOIN]


.. include:: tm.rst.in
  :start-after: [TARGET_GOACC_REDUCTION]
  :end-before: [TARGET_GOACC_REDUCTION]


.. include:: tm.rst.in
  :start-after: [TARGET_PREFERRED_ELSE_VALUE]
  :end-before: [TARGET_PREFERRED_ELSE_VALUE]


.. include:: tm.rst.in
  :start-after: [TARGET_GOACC_ADJUST_PRIVATE_DECL]
  :end-before: [TARGET_GOACC_ADJUST_PRIVATE_DECL]


.. include:: tm.rst.in
  :start-after: [TARGET_GOACC_EXPAND_VAR_DECL]
  :end-before: [TARGET_GOACC_EXPAND_VAR_DECL]


.. include:: tm.rst.in
  :start-after: [TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD]
  :end-before: [TARGET_GOACC_CREATE_WORKER_BROADCAST_RECORD]


.. include:: tm.rst.in
  :start-after: [TARGET_GOACC_SHARED_MEM_LAYOUT]
  :end-before: [TARGET_GOACC_SHARED_MEM_LAYOUT]
