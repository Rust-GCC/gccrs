..
  Copyright 1988-2022 Free Software Foundation, Inc.
  This is part of the GCC manual.
  For copying conditions, see the copyright.rst file.

.. _interoperation:

Interoperation
**************

This section lists various difficulties encountered in using GCC
together with other compilers or with the assemblers, linkers,
libraries and debuggers on certain systems.

* On many platforms, GCC supports a different ABI for C++ than do other
  compilers, so the object files compiled by GCC cannot be used with object
  files generated by another C++ compiler.

  An area where the difference is most apparent is name mangling.  The use
  of different name mangling is intentional, to protect you from more subtle
  problems.
  Compilers differ as to many internal details of C++ implementation,
  including: how class instances are laid out, how multiple inheritance is
  implemented, and how virtual function calls are handled.  If the name
  encoding were made the same, your programs would link against libraries
  provided from other compilers---but the programs would then crash when
  run.  Incompatible libraries are then detected at link time, rather than
  at run time.

* On some BSD systems, including some versions of Ultrix, use of profiling
  causes static variable destructors (currently used only in C++) not to
  be run.

* On a SPARC, GCC aligns all values of type ``double`` on an 8-byte
  boundary, and it expects every ``double`` to be so aligned.  The Sun
  compiler usually gives ``double`` values 8-byte alignment, with one
  exception: function arguments of type ``double`` may not be aligned.

  As a result, if a function compiled with Sun CC takes the address of an
  argument of type ``double`` and passes this pointer of type
  ``double *`` to a function compiled with GCC, dereferencing the
  pointer may cause a fatal signal.

  One way to solve this problem is to compile your entire program with GCC.
  Another solution is to modify the function that is compiled with
  Sun CC to copy the argument into a local variable; local variables
  are always properly aligned.  A third solution is to modify the function
  that uses the pointer to dereference it via the following function
  ``access_double`` instead of directly with :samp:`*`:

  .. code-block:: c++

    inline double
    access_double (double *unaligned_ptr)
    {
      union d2i { double d; int i[2]; };

      union d2i *p = (union d2i *) unaligned_ptr;
      union d2i u;

      u.i[0] = p->i[0];
      u.i[1] = p->i[1];

      return u.d;
    }

  Storing into the pointer can be done likewise with the same union.

* On Solaris, the ``malloc`` function in the :samp:`libmalloc.a` library
  may allocate memory that is only 4 byte aligned.  Since GCC on the
  SPARC assumes that doubles are 8 byte aligned, this may result in a
  fatal signal if doubles are stored in memory allocated by the
  :samp:`libmalloc.a` library.

  The solution is to not use the :samp:`libmalloc.a` library.  Use instead
  ``malloc`` and related functions from :samp:`libc.a`; they do not have
  this problem.

* On the HP PA machine, ADB sometimes fails to work on functions compiled
  with GCC.  Specifically, it fails to work on functions that use
  ``alloca`` or variable-size arrays.  This is because GCC doesn't
  generate HP-UX unwind descriptors for such functions.  It may even be
  impossible to generate them.

* Debugging (:option:`-g`) is not supported on the HP PA machine, unless you use
  the preliminary GNU tools.

* Taking the address of a label may generate errors from the HP-UX
  PA assembler.  GAS for the PA does not have this problem.

* Using floating point parameters for indirect calls to static functions
  will not work when using the HP assembler.  There simply is no way for GCC
  to specify what registers hold arguments for static functions when using
  the HP assembler.  GAS for the PA does not have this problem.

* In extremely rare cases involving some very large functions you may
  receive errors from the HP linker complaining about an out of bounds
  unconditional branch offset.  This used to occur more often in previous
  versions of GCC, but is now exceptionally rare.  If you should run
  into it, you can work around by making your function smaller.

* GCC compiled code sometimes emits warnings from the HP-UX assembler of
  the form:

  .. code-block:: c++

    (warning) Use of GR3 when
      frame >= 8192 may cause conflict.

  These warnings are harmless and can be safely ignored.

* In extremely rare cases involving some very large functions you may
  receive errors from the AIX Assembler complaining about a displacement
  that is too large.  If you should run into it, you can work around by
  making your function smaller.

* The :samp:`libstdc++.a` library in GCC relies on the SVR4 dynamic
  linker semantics which merges global symbols between libraries and
  applications, especially necessary for C++ streams functionality.
  This is not the default behavior of AIX shared libraries and dynamic
  linking.  :samp:`libstdc++.a` is built on AIX with 'runtime-linking'
  enabled so that symbol merging can occur.  To utilize this feature,
  the application linked with :samp:`libstdc++.a` must include the
  :option:`-Wl,-brtl` flag on the link line.  G++ cannot impose this
  because this option may interfere with the semantics of the user
  program and users may not always use :samp:`g++` to link his or her
  application.  Applications are not required to use the
  :option:`-Wl,-brtl` flag on the link line---the rest of the
  :samp:`libstdc++.a` library which is not dependent on the symbol
  merging semantics will continue to function correctly.

* An application can interpose its own definition of functions for
  functions invoked by :samp:`libstdc++.a` with 'runtime-linking'
  enabled on AIX.  To accomplish this the application must be linked
  with 'runtime-linking' option and the functions explicitly must be
  exported by the application (:option:`-Wl,-brtl,-bE:exportfile`).

* AIX on the RS/6000 provides support (NLS) for environments outside of
  the United States.  Compilers and assemblers use NLS to support
  locale-specific representations of various objects including
  floating-point numbers (:samp:`.` vs :samp:`,` for separating decimal
  fractions).  There have been problems reported where the library linked
  with GCC does not produce the same floating-point formats that the
  assembler accepts.  If you have this problem, set the :envvar:`LANG`
  environment variable to :samp:`C` or :samp:`En_US`.

*
  .. index:: fdollars-in-identifiers

  Even if you specify :option:`-fdollars-in-identifiers`,
  you cannot successfully use :samp:`$` in identifiers on the RS/6000 due
  to a restriction in the IBM assembler.  GAS supports these
  identifiers.
