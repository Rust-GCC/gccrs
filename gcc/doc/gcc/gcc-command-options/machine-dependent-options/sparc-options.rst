..
  Copyright 1988-2022 Free Software Foundation, Inc.
  This is part of the GCC manual.
  For copying conditions, see the copyright.rst file.

.. program:: SPARC

.. index:: SPARC options

.. _sparc-options:

SPARC Options
^^^^^^^^^^^^^

These :samp:`-m` options are supported on the SPARC:

.. option:: -mno-app-regs, -mapp-regs

  Specify :option:`-mapp-regs` to generate output using the global registers
  2 through 4, which the SPARC SVR4 ABI reserves for applications.  Like the
  global register 1, each global register 2 through 4 is then treated as an
  allocable register that is clobbered by function calls.  This is the default.

  To be fully SVR4 ABI-compliant at the cost of some performance loss,
  specify :option:`-mno-app-regs`.  You should compile libraries and system
  software with this option.

.. option:: -mflat, -mno-flat

  With :option:`-mflat`, the compiler does not generate save/restore instructions
  and uses a 'flat' or single register window model.  This model is compatible
  with the regular register window model.  The local registers and the input
  registers (0--5) are still treated as 'call-saved' registers and are
  saved on the stack as needed.

  With :option:`-mno-flat` (the default), the compiler generates save/restore
  instructions (except for leaf functions).  This is the normal operating mode.

.. option:: -mfpu, -mhard-float

  Generate output containing floating-point instructions.  This is the
  default.

.. option:: -mno-fpu, -msoft-float

  Generate output containing library calls for floating point.

  .. warning::

    The requisite libraries are not available for all SPARC
    targets.  Normally the facilities of the machine's usual C compiler are
    used, but this cannot be done directly in cross-compilation.  You must make
    your own arrangements to provide suitable library functions for
    cross-compilation.  The embedded targets :samp:`sparc-*-aout` and
    :samp:`sparclite-*-*` do provide software floating-point support.

  :option:`-msoft-float` changes the calling convention in the output file;
  therefore, it is only useful if you compile *all* of a program with
  this option.  In particular, you need to compile :samp:`libgcc.a`, the
  library that comes with GCC, with :option:`-msoft-float` in order for
  this to work.

.. option:: -mhard-quad-float

  Generate output containing quad-word (long double) floating-point
  instructions.

.. option:: -msoft-quad-float

  Generate output containing library calls for quad-word (long double)
  floating-point instructions.  The functions called are those specified
  in the SPARC ABI.  This is the default.

  As of this writing, there are no SPARC implementations that have hardware
  support for the quad-word floating-point instructions.  They all invoke
  a trap handler for one of these instructions, and then the trap handler
  emulates the effect of the instruction.  Because of the trap handler overhead,
  this is much slower than calling the ABI library routines.  Thus the
  :option:`-msoft-quad-float` option is the default.

.. option:: -mno-unaligned-doubles, -munaligned-doubles

  Assume that doubles have 8-byte alignment.  This is the default.

  With :option:`-munaligned-doubles`, GCC assumes that doubles have 8-byte
  alignment only if they are contained in another type, or if they have an
  absolute address.  Otherwise, it assumes they have 4-byte alignment.
  Specifying this option avoids some rare compatibility problems with code
  generated by other compilers.  It is not the default because it results
  in a performance loss, especially for floating-point code.

.. option:: -muser-mode, -mno-user-mode

  Do not generate code that can only run in supervisor mode.  This is relevant
  only for the ``casa`` instruction emitted for the LEON3 processor.  This
  is the default.

.. option:: -mfaster-structs, -mno-faster-structs

  With :option:`-mfaster-structs`, the compiler assumes that structures
  should have 8-byte alignment.  This enables the use of pairs of
  ``ldd`` and ``std`` instructions for copies in structure
  assignment, in place of twice as many ``ld`` and ``st`` pairs.
  However, the use of this changed alignment directly violates the SPARC
  ABI.  Thus, it's intended only for use on targets where the developer
  acknowledges that their resulting code is not directly in line with
  the rules of the ABI.

.. option:: -mstd-struct-return, -mno-std-struct-return

  With :option:`-mstd-struct-return`, the compiler generates checking code
  in functions returning structures or unions to detect size mismatches
  between the two sides of function calls, as per the 32-bit ABI.

  The default is :option:`-mno-std-struct-return`.  This option has no effect
  in 64-bit mode.

.. option:: -mlra, -mno-lra

  Enable Local Register Allocation.  This is the default for SPARC since GCC 7
  so :option:`-mno-lra` needs to be passed to get old Reload.

.. option:: -mcpu={cpu_type}

  Set the instruction set, register set, and instruction scheduling parameters
  for machine type :samp:`{cpu_type}`.  Supported values for :samp:`{cpu_type}` are
  :samp:`v7`, :samp:`cypress`, :samp:`v8`, :samp:`supersparc`, :samp:`hypersparc`,
  :samp:`leon`, :samp:`leon3`, :samp:`leon3v7`, :samp:`leon5`, :samp:`sparclite`,
  :samp:`f930`, :samp:`f934`, :samp:`sparclite86x`, :samp:`sparclet`, :samp:`tsc701`,
  :samp:`v9`, :samp:`ultrasparc`, :samp:`ultrasparc3`, :samp:`niagara`,
  :samp:`niagara2`, :samp:`niagara3`, :samp:`niagara4`, :samp:`niagara7` and
  :samp:`m8`.

  Native Solaris and GNU/Linux toolchains also support the value :samp:`native`,
  which selects the best architecture option for the host processor.
  :option:`-mcpu=native` has no effect if GCC does not recognize
  the processor.

  Default instruction scheduling parameters are used for values that select
  an architecture and not an implementation.  These are :samp:`v7`, :samp:`v8`,
  :samp:`sparclite`, :samp:`sparclet`, :samp:`v9`.

  Here is a list of each supported architecture and their supported
  implementations.

  v7
    cypress, leon3v7

  v8
    supersparc, hypersparc, leon, leon3, leon5

  sparclite
    f930, f934, sparclite86x

  sparclet
    tsc701

  v9
    ultrasparc, ultrasparc3, niagara, niagara2, niagara3, niagara4,
    niagara7, m8

  By default (unless configured otherwise), GCC generates code for the V7
  variant of the SPARC architecture.  With :option:`-mcpu=cypress`, the compiler
  additionally optimizes it for the Cypress CY7C602 chip, as used in the
  SPARCStation/SPARCServer 3xx series.  This is also appropriate for the older
  SPARCStation 1, 2, IPX etc.

  With :option:`-mcpu=v8`, GCC generates code for the V8 variant of the SPARC
  architecture.  The only difference from V7 code is that the compiler emits
  the integer multiply and integer divide instructions which exist in SPARC-V8
  but not in SPARC-V7.  With :option:`-mcpu=supersparc`, the compiler additionally
  optimizes it for the SuperSPARC chip, as used in the SPARCStation 10, 1000 and
  2000 series.

  With :option:`-mcpu=sparclite`, GCC generates code for the SPARClite variant of
  the SPARC architecture.  This adds the integer multiply, integer divide step
  and scan (``ffs``) instructions which exist in SPARClite but not in SPARC-V7.
  With :option:`-mcpu=f930`, the compiler additionally optimizes it for the
  Fujitsu MB86930 chip, which is the original SPARClite, with no FPU.  With
  :option:`-mcpu=f934`, the compiler additionally optimizes it for the Fujitsu
  MB86934 chip, which is the more recent SPARClite with FPU.

  With :option:`-mcpu=sparclet`, GCC generates code for the SPARClet variant of
  the SPARC architecture.  This adds the integer multiply, multiply/accumulate,
  integer divide step and scan (``ffs``) instructions which exist in SPARClet
  but not in SPARC-V7.  With :option:`-mcpu=tsc701`, the compiler additionally
  optimizes it for the TEMIC SPARClet chip.

  With :option:`-mcpu=v9`, GCC generates code for the V9 variant of the SPARC
  architecture.  This adds 64-bit integer and floating-point move instructions,
  3 additional floating-point condition code registers and conditional move
  instructions.  With :option:`-mcpu=ultrasparc`, the compiler additionally
  optimizes it for the Sun UltraSPARC I/II/IIi chips.  With
  :option:`-mcpu=ultrasparc3`, the compiler additionally optimizes it for the
  Sun UltraSPARC III/III+/IIIi/IIIi+/IV/IV+ chips.  With
  :option:`-mcpu=niagara`, the compiler additionally optimizes it for
  Sun UltraSPARC T1 chips.  With :option:`-mcpu=niagara2`, the compiler
  additionally optimizes it for Sun UltraSPARC T2 chips. With
  :option:`-mcpu=niagara3`, the compiler additionally optimizes it for Sun
  UltraSPARC T3 chips.  With :option:`-mcpu=niagara4`, the compiler
  additionally optimizes it for Sun UltraSPARC T4 chips.  With
  :option:`-mcpu=niagara7`, the compiler additionally optimizes it for
  Oracle SPARC M7 chips.  With :option:`-mcpu=m8`, the compiler
  additionally optimizes it for Oracle M8 chips.

.. option:: -mtune={cpu_type}

  Set the instruction scheduling parameters for machine type
  :samp:`{cpu_type}`, but do not set the instruction set or register set that the
  option :option:`-mcpu=cpu_type` does.

  The same values for :option:`-mcpu=cpu_type` can be used for
  :option:`-mtune=cpu_type`, but the only useful values are those
  that select a particular CPU implementation.  Those are
  :samp:`cypress`, :samp:`supersparc`, :samp:`hypersparc`, :samp:`leon`,
  :samp:`leon3`, :samp:`leon3v7`, :samp:`leon5`, :samp:`f930`, :samp:`f934`,
  :samp:`sparclite86x`, :samp:`tsc701`, :samp:`ultrasparc`,
  :samp:`ultrasparc3`, :samp:`niagara`, :samp:`niagara2`, :samp:`niagara3`,
  :samp:`niagara4`, :samp:`niagara7` and :samp:`m8`.  With native Solaris
  and GNU/Linux toolchains, :samp:`native` can also be used.

.. option:: -mv8plus, -mno-v8plus

  With :option:`-mv8plus`, GCC generates code for the SPARC-V8+ ABI.  The
  difference from the V8 ABI is that the global and out registers are
  considered 64 bits wide.  This is enabled by default on Solaris in 32-bit
  mode for all SPARC-V9 processors.

.. option:: -mvis, -mno-vis

  With :option:`-mvis`, GCC generates code that takes advantage of the UltraSPARC
  Visual Instruction Set extensions.  The default is :option:`-mno-vis`.

.. option:: -mvis2, -mno-vis2

  With :option:`-mvis2`, GCC generates code that takes advantage of
  version 2.0 of the UltraSPARC Visual Instruction Set extensions.  The
  default is :option:`-mvis2` when targeting a cpu that supports such
  instructions, such as UltraSPARC-III and later.  Setting :option:`-mvis2`
  also sets :option:`-mvis`.

.. option:: -mvis3, -mno-vis3

  With :option:`-mvis3`, GCC generates code that takes advantage of
  version 3.0 of the UltraSPARC Visual Instruction Set extensions.  The
  default is :option:`-mvis3` when targeting a cpu that supports such
  instructions, such as niagara-3 and later.  Setting :option:`-mvis3`
  also sets :option:`-mvis2` and :option:`-mvis`.

.. option:: -mvis4, -mno-vis4

  With :option:`-mvis4`, GCC generates code that takes advantage of
  version 4.0 of the UltraSPARC Visual Instruction Set extensions.  The
  default is :option:`-mvis4` when targeting a cpu that supports such
  instructions, such as niagara-7 and later.  Setting :option:`-mvis4`
  also sets :option:`-mvis3`, :option:`-mvis2` and :option:`-mvis`.

.. option:: -mvis4b, -mno-vis4b

  With :option:`-mvis4b`, GCC generates code that takes advantage of
  version 4.0 of the UltraSPARC Visual Instruction Set extensions, plus
  the additional VIS instructions introduced in the Oracle SPARC
  Architecture 2017.  The default is :option:`-mvis4b` when targeting a
  cpu that supports such instructions, such as m8 and later.  Setting
  :option:`-mvis4b` also sets :option:`-mvis4`, :option:`-mvis3`,
  :option:`-mvis2` and :option:`-mvis`.

.. option:: -mcbcond, -mno-cbcond

  With :option:`-mcbcond`, GCC generates code that takes advantage of the UltraSPARC
  Compare-and-Branch-on-Condition instructions.  The default is :option:`-mcbcond`
  when targeting a CPU that supports such instructions, such as Niagara-4 and
  later.

.. option:: -mfmaf, -mno-fmaf

  With :option:`-mfmaf`, GCC generates code that takes advantage of the UltraSPARC
  Fused Multiply-Add Floating-point instructions.  The default is :option:`-mfmaf`
  when targeting a CPU that supports such instructions, such as Niagara-3 and
  later.

.. option:: -mfsmuld, -mno-fsmuld

  With :option:`-mfsmuld`, GCC generates code that takes advantage of the
  Floating-point Multiply Single to Double (FsMULd) instruction.  The default is
  :option:`-mfsmuld` when targeting a CPU supporting the architecture versions V8
  or V9 with FPU except :option:`-mcpu=leon`.

.. option:: -mpopc, -mno-popc

  With :option:`-mpopc`, GCC generates code that takes advantage of the UltraSPARC
  Population Count instruction.  The default is :option:`-mpopc`
  when targeting a CPU that supports such an instruction, such as Niagara-2 and
  later.

.. option:: -msubxc, -mno-subxc

  With :option:`-msubxc`, GCC generates code that takes advantage of the UltraSPARC
  Subtract-Extended-with-Carry instruction.  The default is :option:`-msubxc`
  when targeting a CPU that supports such an instruction, such as Niagara-7 and
  later.

.. option:: -mfix-at697f

  Enable the documented workaround for the single erratum of the Atmel AT697F
  processor (which corresponds to erratum #13 of the AT697E processor).

.. option:: -mfix-ut699

  Enable the documented workarounds for the floating-point errata and the data
  cache nullify errata of the UT699 processor.

.. option:: -mfix-ut700

  Enable the documented workaround for the back-to-back store errata of
  the UT699E/UT700 processor.

.. option:: -mfix-gr712rc

  Enable the documented workaround for the back-to-back store errata of
  the GR712RC processor.

These :samp:`-m` options are supported in addition to the above
on SPARC-V9 processors in 64-bit environments:

.. option:: -m32, -m64

  Generate code for a 32-bit or 64-bit environment.
  The 32-bit environment sets int, long and pointer to 32 bits.
  The 64-bit environment sets int to 32 bits and long and pointer
  to 64 bits.

.. option:: -mcmodel={which}

  Set the code model to one of

  :samp:`medlow`
    The Medium/Low code model: 64-bit addresses, programs
    must be linked in the low 32 bits of memory.  Programs can be statically
    or dynamically linked.

  :samp:`medmid`
    The Medium/Middle code model: 64-bit addresses, programs
    must be linked in the low 44 bits of memory, the text and data segments must
    be less than 2GB in size and the data segment must be located within 2GB of
    the text segment.

  :samp:`medany`
    The Medium/Anywhere code model: 64-bit addresses, programs
    may be linked anywhere in memory, the text and data segments must be less
    than 2GB in size and the data segment must be located within 2GB of the
    text segment.

  :samp:`embmedany`
    The Medium/Anywhere code model for embedded systems:
    64-bit addresses, the text and data segments must be less than 2GB in
    size, both starting anywhere in memory (determined at link time).  The
    global register %g4 points to the base of the data segment.  Programs
    are statically linked and PIC is not supported.

.. option:: -mmemory-model={mem-model}

  Set the memory model in force on the processor to one of

  :samp:`default`
    The default memory model for the processor and operating system.

  :samp:`rmo`
    Relaxed Memory Order

  :samp:`pso`
    Partial Store Order

  :samp:`tso`
    Total Store Order

  :samp:`sc`
    Sequential Consistency

  These memory models are formally defined in Appendix D of the SPARC-V9
  architecture manual, as set in the processor's ``PSTATE.MM`` field.

.. option:: -mstack-bias, -mno-stack-bias

  With :option:`-mstack-bias`, GCC assumes that the stack pointer, and
  frame pointer if present, are offset by -2047 which must be added back
  when making stack frame references.  This is the default in 64-bit mode.
  Otherwise, assume no such offset is present.
