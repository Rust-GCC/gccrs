TO notes:

This is the actual compiler frontend.

What needs to occur in a frontend according to GCC docs:

Parsing pass:
-Language frontend is only invoked once via lang_hooks.parse_file (which parses any input)
-Frontend may use any intermediate language representation deemed appropriate (i.e. could use MIR like in actual Rust, but GENERIC trees would probably be used)
-At some point, the frontend must translate the intermediate language representation used inside it to a representation understood by the rest of the compiler (GIMPLE or maybe GENERIC). There are two current ways of doing this:
	-C frontend manually invokes gimplifier on each function, and uses gimplifier callbacks to convert language-specific tree nodes directly to GIMPLE before passing function off to be compiled. 
	-Fortran frontend converts from private representation to GENERIC, which is later lowered to GIMPLE when the function is compiled.
	-Also, a front end could generate GIMPLE directly, which is a "moderately complex process" but would maybe mean that more of the Rust LLVM frontend could be used without modification.
	-Which route to choose depends on how well GENERIC (plus extensions) can be made to match up with the source language and necessary parsing data structures. The easiest seems to be the Fortran method, i.e. just make GENERIC. 
-Note that each function (and top level declaration) must be passed separately to the middle end or something. Function and data definitions must be passed to the middle-end, and for debug info, data and type declarations should also be passed.
-Front end needs complete top-level function or data declaration, and each data definition should be passed to rest_of_decl_compilation . Each complete type definition should be passed to rest_of_type_compilation . Each function definition should be passed to cgraph_finalize_function .
-Middle-end will either emit the function and data definitions immediately or queue them for later processing.

Gimplification pass:
-Consists of conversion of frontend's intermediate representation to GIMPLE
-Main entry point is gimplify_function_tree in gimplify.c . From here, the entire function is processed, gimplifying each statement in turn. Main workhorse for this pass is gimplify_expr . Approximately everything passes through here at least once, and it is from here that we invoke lang_hooks.gimplify_expr callback.
-Callback should examine the expression and return GS_UNHANDLED if the expression is not a language-specific construct that requires attention. Otherwise it should alter the expression in some way to progress towards it being valid GIMPLE. If callback is certain that transformation is complete and expression is valid GIMPLE, should return GS_ALL_DONE . Otherwise, return GS_OK , which causes expression to be processed again. If callback encounters error during transformation (because frontend relies on gimplification to finish semantic checks), return GS_ERROR .

Pass manager:
-Pass manager is located in passes.c, tree-optimize.c, and tree-pass.h . It processes passes as defined in passes.def . It runs all passes in correct order. etc. more stuff

After this, the AST should be built in GIMPLE or whatever, so the middle-end and back-end of GCC take care of the rest of compilation, I hope. 



Notes on GENERIC:
-A language-independent way of representing an entire _function_ in trees. If you can express it with gcc/tree.def, it's GENERIC.
-A statement is defined as an expression whose value, if any, is ignored. A statement will always have TREE_SIDE_EFFECTS set, but a non-statement expression may also have side effects, e.g. CALL_EXPR (probably a function call).
-Implication that frontends lower GENERIC to GIMPLE.

Trees:
-The central data structure, tree, is a node of C type tree. It is a pointer type, but the object it points to may be a variety of types.
-Can tell what kind of a node a tree is by using TREE_CODE macro. Many macros take trees as input and return trees as output. Most require a certain kind of tree node as input, i.e. there is a particular type system for trees not reflected in C's type system.
-For safety, useful to configure GCC with --enable-checking . All tree types are checked at runtime as a result, destroying performance but aiding debugging.
-Many macros behave as predicates (a function used to test something about a supplied argument - e.g. lambda expression LINQ), and many, though not all, of these end in _P . Don't rely on result type of macros being of any particular type, but may rely on fact that type can be compared to 0, so statements like "int i = (TEST_P(t) != 0);" are legal. Macros that return int values now may be changed to return tree values, or other pointers in the future. Thus, should not write code like "if (TEST_P(t) == 1)".
-



Notes on basic outline:
-rustc and mrustc appear to use a hand-written recursive-descent parser, not a bison-generated LALR parser.
-I don't know if redbrain's original parser was bison LALR or handwritten recursive-descent - it seemed to have aspects of both. However, he mentioned using a bison-generated parser initially and then moving to a handwritten one later.
-As such, own parser should probably be hand-written recursive-descent.